% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spawn-glycans.R
\name{spawn_glycans_step}
\alias{spawn_glycans_step}
\alias{spawn_glycans}
\title{Apply Enzymes to Spawn Glycans}
\usage{
spawn_glycans_step(glycans, enzymes)

spawn_glycans(glycans, enzymes, n_steps = 5, filter = NULL)
}
\arguments{
\item{glycans}{A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}}, or a character vector of
glycan structure strings supported by \code{\link[glyparse:auto_parse]{glyparse::auto_parse()}}.}

\item{enzymes}{A character vector of gene symbols,
or a list of \code{\link[=enzyme]{enzyme()}} objects.}

\item{n_steps}{The maximum number of rounds to perform.
The actual number of rounds may be less if no new glycans can be generated.}

\item{filter}{A function to filter the generated glycans.
It should have a single \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} vector as input,
and return a logical vector of the same length.
The function will be called on the results after each round.}
}
\value{
A \code{\link[glyrepr:glycan_structure]{glyrepr::glycan_structure()}} vector of all unique glycans generated.
}
\description{
This function simulates the action of enzymes on glycans.
Think of it like a primordial soup where you put in a few glycans and enzymes,
and let them interact to generate new glycans.

\code{spawn_glycans_step()} performs one round of enzyme action,
while \code{spawn_glycans()} performs multiple rounds.
The only difference between \code{spawn_glycans_step()} and \code{spawn_glycans(n_steps = 1)}
is that the latter returns the original input glycans as well.
For both, a vector of unique glycan structures is returned.

The number of glycans generated by \code{spawn_glycans()} is typically exponential,
and can quickly become very large.
Therefore, it is recommended to use a small number
of steps and carefully select the enzymes.
Also, you can use the \code{filter} argument to prune the results after each round.
}
\section{Important notes}{
Here are some important notes for all functions in the \code{glyenzy} package.
\subsection{Applicability}{

All algorithms and enzyme information in glyenzy are applicable only to humans,
and specifically to N-glycans and O-GalNAc glycans.
Results may be inaccurate for other types of glycans (e.g., GAGs, glycolipids)
or for glycans in other species (e.g., plants, insects).
}

\subsection{Inclusiveness}{

The algorithm takes an intentionally inclusive approach,
assuming that all possible isoenzymes capable of catalyzing
a given reaction may be involved.
Therefore, results should be interpreted with caution.

For example, in humans, detection of the motif "Neu5Ac(a2-3)Gal(b1-" will return
both "ST3GAL3" and "ST3GAL4". In reality, only one of them might be active, depending
on factors such as tissue specificity.
}

\subsection{Only "concrete" glycans}{

The function only works for glycans containing \strong{concrete} residues
(e.g., \code{"Glc"}, \code{"GalNAc"}), and not for glycans with \strong{generic}
residues (e.g., \code{"Hex"}, \code{"HexNAc"}).
}

\subsection{Substituents}{

Subtituents (e.g. sulfation, phosphorylation) is not supported yet,
and the algorithms might fail for glycans with subtituents.
If your glycans contains substituents,
use \code{\link[glyrepr:remove_substituents]{glyrepr::remove_substituents()}} to get clean glycans.
}

\subsection{Incomplete glycan structures}{

If the glycan structure is incomplete or partially degraded,
the result may be misleading.
}

\subsection{Starting points}{

Throughout \code{glyenzy}, the starting glycan is the Glc(3)Man(9)GlcNAc(2) precursor for N-glycans,
and GalNAc(a1- for O-glycans.
This means that enzymes involved in N-glycan precursor biosynthesis, mainly ALGs,
and OST, which transfered the precursor to Asn, are not considered here.
Similarly, GALNTs for O-glycans are not considered.
}
}

\examples{
# Use `spawn_glycans_step()` to build glycans step by step
glycan <- "GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-"
glycan |>
  spawn_glycans_step("MGAT2") |>
  spawn_glycans_step("B4GALT1") |>
  spawn_glycans_step("ST3GAL3")

# Use `spawn_glycans()` to simulate a primordial soup
glycans <- c(
  "GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-",
  "GlcNAc(b1-2)Man(a1-3)[GlcNAc(b1-2)Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-"
)
enzymes <- c("B4GALT1", "ST3GAL3")
spawn_glycans(glycans, enzymes, n_steps = 5)

# Use `filter` to prune the results after each round
# Here we keep only glycans that are synthesized by MGAT2
spawn_glycans(glycans, enzymes, n_steps = 5, filter = ~ is_synthesized_by(.x, "MGAT2"))

}
