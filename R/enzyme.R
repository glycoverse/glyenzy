#' Enzymes
#'
#' @description
#' Glycosylation is catalyzed by two types of enzymes: glycosyltransferases (GTs) and glycoside hydrolases (GHs).
#' Glycosyltransferases catalyze the transfer of a sugar residue from a donor to an acceptor.
#' Glycoside hydrolases catalyze the removal of a sugar residue from a substrate.
#' `glyenzy` provides a data structure (`glyenzy_enzyme`) to represent these enzymes.
#'
#' Use `enzyme()` with a gene symbol to load a predefined enzyme.
#' For example, use `enzyme("ST3GAL3")` to load the enzyme ST3GAL3.
#'
#' Throughout the package, you can use `enzyme()`s for any `enzyme` argument,
#' or just use the gene symbol directly.
#' For example, `involve("Neu5Ac(a2-3)Gal(b1-3)GalNAc(a1-", "ST3GAL3")` and
#' `involve("Neu5Ac(a2-3)Gal(b1-3)GalNAc(a1-", enzyme("ST3GAL3"))` are equivalent.
#'
#' @details
#'
#' # Explanation about `glyenzy_enzyme`
#'
#' An `enzyme()` is a list with the following elements:
#'
#' 1. `name`: the name of the enzyme, usually the gene symbol.
#' 2. `rules`: a list of `glyenzy_enzyme_rule` objects.
#'    Each rule is a list with the following fields:
#'    - `acceptor`: the motif that the enzyme recognizes
#'    - `acceptor_alignment`: the alignment of the `acceptor`
#'    - `rejects`: the motifs that the enzyme reject to act on
#'    - `rejects_alignment`: the alignment of `rejects`
#'    - `product`: the product generated by the enzyme
#'    - `acceptor_idx`: the node index of the acceptor where the enzyme acts on.
#'      For GTs, this is the node new residue is attached to.
#'      For GHs, this is the node that is removed.
#'    - `product_idx`: the node index of the product residue in the product structure.
#'      For GTs, this is the index of the newly added residue in the product.
#'      For GHs, this is `NULL` (no new residue is added).
#'    - `new_residue`: the new residue added by the enzyme. For GHs, this is `NULL`.
#'    - `new_linkage`: the linkage of the new residue. For GHs, this is `NULL`.
#' 3. `type`: the type of the enzyme, "GT" for glycosyltransferase or "GH" for glycoside hydrolase.
#' 4. `species`: the species of the enzyme, e.g. "human" or "mouse".
#'
#' You can see all these information by printing the enzyme object.
#'
#' @param symbol The gene symbol of the enzyme.
#'
#' @return A `glyenzy_enzyme` object.
#'
#' @examples
#' library(glyrepr)
#'
#' enzyme("ST3GAL3")
#'
#' @export
enzyme <- function(symbol) {
  checkmate::assert_string(symbol)
  if (symbol %in% names(glyenzy_enzymes)) {
    glyenzy_enzymes[[symbol]]
  } else {
    cli::cli_abort("Unknown enzyme: {.val {symbol}}.")
  }
}

#' Get all enzymes
#'
#' Return a named list of all built-in enzymes,
#' or a character vector of gene symbols if `return_str` is `TRUE`.
#'
#' @param return_str If `FALSE` (default), returns the enzyme list.
#'   Otherwise returns a charactor vector of gene symbols.
#'
#' @returns A list of [enzyme()]s or a character vector.
#' @examples
#' all_enzymes(return_str = TRUE)
#'
#' @export
all_enzymes <- function(return_str = FALSE) {
  if (return_str) {
    return(names(glyenzy_enzymes))
  } else {
    return(glyenzy_enzymes)
  }
}

#' Create a new enzyme object
#'
#' @param name The name of the enzyme.
#' @param rules A list of `glyenzy_enzyme_rule` objects.
#' @param type The type of the enzyme, "GT" for glycosyltransferase or "GH" for glycoside hydrolase.
#' @param species The species of the enzyme, e.g. "human" or "mouse".
#'
#' @return A `glyenzy_enzyme` object.
#' @noRd
new_enzyme <- function(name, rules, type, species) {
  checkmate::assert_string(name)
  checkmate::assert_list(rules, types = "glyenzy_enzyme_rule")
  checkmate::assert_choice(type, c("GT", "GH"))
  checkmate::assert_string(species)

  structure(
    list(name = name, rules = rules, type = type, species = species),
    class = "glyenzy_enzyme"
  )
}

#' Validate a `glyenzy_enzyme` object
#'
#' @param x A `glyenzy_enzyme` object.
#' @noRd
validate_enzyme <- function(x) {
  checkmate::assert_class(x, "glyenzy_enzyme")
  purrr::walk(x$rules, ~ validate_enzyme_rule(.x, type = x$type))
  invisible(x)
}

#' Enhance a `glyenzy_enzyme` object
#'
#' This function enhances all rules by calling `enhance_enzyme_rule()` on each rule.
#'
#' @param x A `glyenzy_enzyme` object.
#' @noRd
enhance_enzyme <- function(x) {
  x$rules <- purrr::map(x$rules, ~ enhance_enzyme_rule(.x, x$type))
  x
}

#' Create a new enzyme rule object
#'
#' An enzyme rule defines one reaction of an enzyme.
#' An enzyme can have multiple rules.
#'
#' @param acceptor A `glyrepr_structure` scalar, representing the motif recognized by the enzyme.
#' @param product A `glyrepr_structure` scalar, representing the product generated by the enzyme.
#' @param acceptor_alignment A character string, representing the alignment of the `acceptor`.
#' @param rejects A `glyrepr_structure` vector, representing the motifs that the enzyme rejects.
#' @param rejects_alignment A character vector, representing the alignment of the `rejects`.
#'
#' @noRd
new_enzyme_rule <- function(acceptor, product, acceptor_alignment, rejects, rejects_alignment) {
  checkmate::assert_class(acceptor, "glyrepr_structure")
  checkmate::assert_class(product, "glyrepr_structure")
  checkmate::assert_choice(acceptor_alignment, c("substructure", "core", "terminal", "whole"))
  checkmate::assert_class(rejects, "glyrepr_structure")
  checkmate::assert_subset(rejects_alignment, c("substructure", "core", "terminal", "whole"))

  structure(
    list(
      acceptor = acceptor,
      product = product,
      acceptor_alignment = acceptor_alignment,
      rejects = rejects,
      rejects_alignment = rejects_alignment
    ),
    class = "glyenzy_enzyme_rule"
  )
}

#' Validate a `glyenzy_enzyme_rule` object
#'
#' This function checks four things:
#' 1. `acceptor` and `product` are both single structures
#' 2. `rejects` and `rejects_alignment` have the same length
#' 3. `acceptor` and `product` are valid for the enzyme type
#' 4. `acceptor` is the substructure of all `rejects`
#'
#' @param x A `glyenzy_enzyme_rule` object.
#' @param type A character string, representing the type of the enzyme, "GT" or "GH".
#' @noRd
validate_enzyme_rule <- function(x, type) {
  checkmate::assert_class(x, "glyenzy_enzyme_rule")

  if (length(x$acceptor) != 1) {
    cli::cli_abort("The {.arg acceptor} must be a single structure.")
  }
  if (length(x$product) != 1) {
    cli::cli_abort("The {.arg product} must be a single structure.")
  }

  if (length(x$rejects) != length(x$rejects_alignment)) {
    cli::cli_abort(c(
      "The length of {.arg rejects} must be equal to the length of {.arg rejects_alignment}.",
      "i" = "Length of {.arg rejects}: {.val {length(x$rejects)}}.",
      "i" = "Length of {.arg rejects_alignment}: {.val {length(x$rejects_alignment)}}."
    ))
  }

  switch(
    type,
    GT = .check_product_acceptor(x$acceptor, x$product, "acceptor", "product"),
    GH = .check_product_acceptor(x$product, x$acceptor, "product", "acceptor"),
    cli::cli_abort("Unsupported enzyme type: {type}")
  )

  if (length(x$rejects) > 0) {
    if (x$acceptor_alignment == "whole") {
      cli::cli_abort("Cannot set {.field rejects} when the acceptor alignment is {.val whole}.")
    }
    if (!all(glymotif::have_motifs(x$rejects, x$acceptor, x$acceptor_alignment))) {
      cli::cli_abort("The {.arg acceptor} must be the substructure of all {.arg rejects}.")
    }
  }

  invisible(x)
}

#' Enhance a `glyenzy_enzyme_rule` object
#'
#' Add the following fields to a `glyenzy_enzyme_rule` object:
#' - `acceptor_idx`: The node index of the acceptor where the enzyme acts on.
#'   For GTs, this is the node new residue is attached to.
#'   For GHs, this is the node that is removed.
#' - `product_idx`: The node index of the product residue in the product structure.
#'   For GTs, this is the index of the newly added residue in the product.
#'   For GHs, this is `NULL` (no new residue is added).
#' - `new_residue`: The new residue added by the enzyme. For GHs, this is `NULL`.
#' - `new_linkage`: The linkage of the new residue. For GHs, this is `NULL`.
#'
#' @param x A `glyenzy_enzyme_rule` object.
#' @param type A character string, representing the type of the enzyme, "GT" or "GH".
#' @noRd
enhance_enzyme_rule <- function(x, type) {
  switch(
    type,
    GT = .enhance_gt_enzyme_rule(x),
    GH = .enhance_gh_enzyme_rule(x)
  )
}

.enhance_gt_enzyme_rule <- function(x) {
  acceptor_graph <- glyrepr::get_structure_graphs(x$acceptor, return_list = FALSE)
  product_graph <- glyrepr::get_structure_graphs(x$product, return_list = FALSE)
  match_res <- glymotif::match_motif(x$product, x$acceptor, alignment = "core")[[1]][[1]]  # only one glycan and one match, so `[[1]][[1]]`

  # The node index of the new residue in the product
  new_residue_idx <- setdiff(1:igraph::vcount(product_graph), match_res)

  # Get the index of its parent node
  parent_idx <- igraph::neighbors(product_graph, new_residue_idx, mode = "in")
  # And map it to the acceptor graph
  acceptor_idx <- match(parent_idx, match_res)
  
  # Get the new residue and new linkage
  new_residue <- igraph::V(product_graph)[new_residue_idx]$mono
  new_linkage <- igraph::incident(product_graph, new_residue_idx, mode = "in")$linkage

  # Add new fields
  x$acceptor_idx <- acceptor_idx
  x$product_idx <- new_residue_idx  # For GT: index of newly added residue in product
  x$new_residue <- new_residue
  x$new_linkage <- new_linkage
  x
}

.enhance_gh_enzyme_rule <- function(x) {
  acceptor_graph <- glyrepr::get_structure_graphs(x$acceptor, return_list = FALSE)
  product_graph <- glyrepr::get_structure_graphs(x$product, return_list = FALSE)
  match_res <- glymotif::match_motif(x$acceptor, x$product, alignment = "core")[[1]][[1]]  # only one glycan, so `[[1]]`

  # The node index of the removed residue in the acceptor
  removed_residue_idx <- setdiff(1:igraph::vcount(acceptor_graph), match_res)

  # Add new fields
  x$acceptor_idx <- removed_residue_idx
  x$product_idx <- NULL  # For GH: no new residue is added
  x$new_residue <- NULL
  x$new_linkage <- NULL
  x
}

#' Check a product-acceptor pair
#'
#' This function checks if a product-acceptor pair is valid.
#' To be a valid pair, the following conditions must be met:
#' 1. `smaller` is a substructure of `larger`
#' 2. `larger` has exactly one more residue than `smaller`
#'
#' @param smaller A `glyrepr_structure` scalar representing the smaller structure.
#' @param larger A `glyrepr_structure` scalar representing the larger structure.
#' @param smaller_name A character string representing the name of the smaller structure.
#'   Used for error messages.
#' @param larger_name A character string representing the name of the larger structure.
#'   Used for error messages.
#'
#' @noRd
.check_product_acceptor <- function(smaller, larger, smaller_name, larger_name) {
  smaller_graph <- glyrepr::get_structure_graphs(smaller, return_list = FALSE)
  larger_graph <- glyrepr::get_structure_graphs(larger, return_list = FALSE)
  match_res <- glymotif::match_motif(larger, smaller, alignment = "core")[[1]]  # only one glycan, so `[[1]]`
  # `smaller` is a substructure of `larger`
  if (length(match_res) != 1) {
    cli::cli_abort("{.arg {smaller_name}} must be a substructure of {.arg {larger_name}}.")
  }
  match_res <- match_res[[1]]  # only one match, so `[[1]]`
  # `larger` has only one more residue than `smaller`
  if (igraph::vcount(larger_graph) - igraph::vcount(smaller_graph) != 1) {
    cli::cli_abort("{.arg {larger_name}} must have exactly one more residue than {.arg {smaller_name}}.")
  }
}

#' Print method for glyenzy_enzyme objects
#'
#' @param x A `glyenzy_enzyme` object.
#' @param ... Additional arguments passed to print methods.
#' @export
print.glyenzy_enzyme <- function(x, ...) {
  cli::cli_h1("Enzyme: {.field {x$name}}")

  # Basic information
  type_str <- switch(
    x$type,
    GT = "Glycosyltransferase",
    GH = "Glycoside hydrolase",
    cli::cli_abort("Unsupported enzyme type: {x$type}")
  )
  cli::cli_alert_info("Type: {.val {x$type}} ({.emph {type_str}})")
  cli::cli_alert_info("Species: {.val {x$species}}")

  # Rules section
  cli::cli_h2("Rules ({.val {length(x$rules)}})")
  if (length(x$rules) > 0) {
    purrr::iwalk(x$rules, function(rule, i) {
      cli::cli_alert("Rule {.val {i}}: {.field {rule$acceptor_alignment}} alignment")
      cli::cli_text("  Acceptor: {.val {as.character(rule$acceptor)}}")
      cli::cli_text("  Product:  {.val {as.character(rule$product)}}")

      # Show rejects for this rule
      if (length(rule$rejects) > 0) {
        cli::cli_text("  Rejects:")
        purrr::iwalk(rule$rejects, function(reject, j) {
          cli::cli_text("    {.val {as.character(reject)}} ({.field {rule$rejects_alignment[j]}})")
        })
      }
    })
  } else {
    cli::cli_text("  {.emph No rules defined}")
  }

  invisible(x)
}