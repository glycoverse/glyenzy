#' Apply an Enzyme to a Glycan
#'
#' This function simulates the action of an enzyme on a glycan.
#' It returns all possible products generated by the enzyme with the given glycans.
#'
#' @inheritSection is_synthesized_by Important notes
#'
#' @param glycans A [glyrepr::glycan_structure()], or a character vector of
#'   glycan structure strings supported by [glyparse::auto_parse()].
#' @param enzyme An [enzyme()] or a gene symbol.
#' @param return_list If `NULL` (default),
#'   return a list of [glyrepr::glycan_structure()] when `glycans` has length greater than 1,
#'   and a single [glyrepr::glycan_structure()] when `glycans` has length 1.
#'   Set to `TRUE` to always return a list.
#'   This can be useful when you are working programmatically with unknown input length.
#'   Note that when `return_list = FALSE` and `length(glycans) > 1`,
#'   an error will be thrown.
#'
#' @return A [glyrepr::glycan_structure()] vector, or a list of such vectors.
#'
#' @examples
#' library(glyrepr)
#' library(glyparse)
#'
#' # Use `glycan_structure()` and `enzyme()`
#' glycan <- auto_parse("GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-")
#' apply_enzyme(glycan, enzyme("MGAT3"))
#'
#' # Or use characters directly
#' apply_enzyme("GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-", "MGAT3")
#'
#' # Vectorized input
#' glycans <- c(
#'   "GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-",
#'   "GlcNAc(b1-2)Man(a1-3)[GlcNAc(b1-2)Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-"
#' )
#' apply_enzyme(glycans, "MGAT3")
#'
#' @export
apply_enzyme <- function(glycans, enzyme, return_list = NULL) {
  glycans <- .process_glycans_arg(glycans)
  enzyme <- .process_enzyme_arg(enzyme)
  checkmate::assert_flag(return_list, null.ok = TRUE)
  if (is.null(return_list)) {
    return_list <- length(glycans) > 1
  }
  if (!return_list && length(glycans) > 1) {
    cli::cli_abort(c(
      "When {.arg return_list} is FALSE, {.arg glycans} must have length 1.",
      "x" = "Length of {.arg glycans}: {.val {length(glycans)}}."
    ))
  }

  res <- .apply_enzyme(glycans, enzyme)
  if (!return_list) {
    res <- res[[1]]
  }
  res
}

#' Apply an enzyme to a vector of glycan graphs
#'
#' @param glycans A `glyrepr_structure` vector of glycan graphs.
#' @param enzyme A `glyenzy_enzyme` object.
#'
#' @returns A list of `glyrepr_structure` vectors, with the same length as `glycans`.
#'   Each element in the list corresponds to the products of the enzyme on the
#'   corresponding glycan in `glycans`.
#' @noRd
.apply_enzyme <- function(glycans, enzyme) {
  glyrepr::smap(glycans, ~ .apply_enzyme_single(.x, enzyme))
}

#' Apply an enzyme to a single glycan graph
#'
#' This function combines all products from each rule.
#'
#' @param graph An igraph object representing the glycan structure.
#' @param enzyme A `glyenzy_enzyme` object.
#'
#' @returns A `glyrepr_structure` vector of all possible products.
#' @noRd
.apply_enzyme_single <- function(graph, enzyme) {
  struc_list <- purrr::map(enzyme$rules, ~ .apply_rule_single(graph, .x, enzyme$type))
  unique(do.call(c, struc_list))
}

#' Apply a single rule to a glycan graph
#'
#' @param graph An igraph object representing the glycan structure.
#' @param rule A `glyenzy_enzyme_rule` object.
#' @param type The type of the enzyme, "GT" or "GH".
#'
#' @returns A `glyrepr_structure` vector of all possible products.
#' @noRd
.apply_rule_single <- function(graph, rule, type) {
  match_res <- .match_rule(graph, rule)
  indices_to_act_on <- purrr::map_int(match_res, ~ .x[rule$acceptor_idx])
  if (type == "GT") {
    graph_list <- purrr::map(indices_to_act_on, ~ .add_residue(graph, .x, rule$new_residue, rule$new_linkage))
    graph_list <- purrr::compact(graph_list)
  } else {
    graph_list <- purrr::map(indices_to_act_on, ~ .remove_residue(graph, .x))
  }
  glyrepr::as_glycan_structure(graph_list)
}

#' Match a rule on a glycan graph
#'
#' @param graph An igraph object representing the glycan structure.
#' @param rule A `glyenzy_enzyme_rule` object.
#'
#' @returns A list of integer vectors, representing the node mapping from the acceptor to the glycan.
#' @noRd
.match_rule <- function(graph, rule) {
  acceptor_graph <- glyrepr::get_structure_graphs(rule$acceptor)

  # Here is an awkard situation.
  # `glyrepr::get_structure_graphs()` returns a list when there are multiple graphs,
  # and a single graph when there is only one graph.
  # This is a bad design because the function is "type-unstable".
  # Before any update is introduced in `glyrepr`, we have to work around it.
  reject_graphs <- glyrepr::get_structure_graphs(rule$rejects)
  if (igraph::is_igraph(reject_graphs)) {
    reject_graphs <- list(reject_graphs)
  }

  for (i in seq_along(reject_graphs)) {
    if (glymotif:::.have_motif_single(graph, reject_graphs[[i]], rule$rejects_alignment[[i]])) {
      return(list())
    }
  }
  glymotif:::.match_motif_single(graph, acceptor_graph, rule$acceptor_alignment)
}

#' Add a residue to a glycan graph
#'
#' @param graph An igraph object representing the glycan structure.
#' @param idx_to_add_on The index of the node to add the new residue on.
#' @param new_residue The new residue "mono" to add.
#' @param new_linkage The "linkage" of the new residue.
#'
#' @returns A new igraph object with the new residue added,
#'   or NULL if the new residue cannot be added.
#' @noRd
.add_residue <- function(graph, idx_to_add_on, new_residue, new_linkage) {
  idx_to_add <- igraph::vcount(graph) + 1
  new_graph <- graph
  new_graph <- igraph::add_vertices(new_graph, 1, attr = list(name = idx_to_add, mono = new_residue, sub = ""))
  new_graph <- igraph::add_edges(new_graph, c(idx_to_add_on, idx_to_add), attr = list(linkage = new_linkage))
  tryCatch({
    glyrepr:::validate_single_glycan_structure(new_graph)
  }, error = function(e) return(NULL))
}

#' Remove a residue from a glycan graph
#'
#' @param graph An igraph object representing the glycan structure.
#' @param idx_to_remove The index of the node to remove.
#'
#' @returns A new igraph object with the residue removed.
#' @noRd
.remove_residue <- function(graph, idx_to_remove) {
  edges <- igraph::incident(graph, idx_to_remove, mode = "all")
  new_graph <- igraph::delete_edges(graph, edges)
  new_graph <- igraph::delete_vertices(new_graph, idx_to_remove)
  # Reset vertex names to maintain consistency with indices after deletion
  igraph::V(new_graph)$name <- as.character(seq_len(igraph::vcount(new_graph)))
  new_graph
}
