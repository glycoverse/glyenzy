#' Apply an Enzyme to a Glycan
#'
#' This function simulates the action of an enzyme on a glycan.
#' It returns all possible products generated by the enzyme with the given glycans.
#'
#' @inheritSection is_synthesized_by Important notes
#'
#' @param glycans A [glyrepr::glycan_structure()], or a character vector of
#'   glycan structure strings supported by [glyparse::auto_parse()].
#' @param enzyme An [enzyme()] or a gene symbol.
#' @param return_list If `NULL` (default),
#'   return a list of [glyrepr::glycan_structure()] when `glycans` has length greater than 1,
#'   and a single [glyrepr::glycan_structure()] when `glycans` has length 1.
#'   Set to `TRUE` to always return a list.
#'   This can be useful when you are working programmatically with unknown input length.
#'   Note that when `return_list = FALSE` and `length(glycans) > 1`,
#'   an error will be thrown.
#'
#' @return A [glyrepr::glycan_structure()] vector, or a list of such vectors.
#'
#' @examples
#' library(glyrepr)
#' library(glyparse)
#'
#' # Use `glycan_structure()` and `enzyme()`
#' glycan <- auto_parse("GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-")
#' apply_enzyme(glycan, enzyme("MGAT3"))
#'
#' # Or use characters directly
#' apply_enzyme("GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-", "MGAT3")
#'
#' # Vectorized input
#' glycans <- c(
#'   "GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-",
#'   "GlcNAc(b1-2)Man(a1-3)[GlcNAc(b1-2)Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-"
#' )
#' apply_enzyme(glycans, "MGAT3")
#'
#' @export
apply_enzyme <- function(glycans, enzyme, return_list = NULL) {
  glycans <- .process_glycans_arg(glycans)
  enzyme <- .process_enzyme_arg(enzyme)
  return_list <- .validate_return_list(return_list, length(glycans))

  res <- .apply_enzyme(glycans, enzyme)
  .format_result(res, return_list)
}

#' Apply an enzyme to a vector of glycan structures
#'
#' @param glycans A `glyrepr_structure` vector.
#' @param enzyme A `glyenzy_enzyme` object.
#'
#' @returns A list of `glyrepr_structure` vectors, with the same length as `glycans`.
#'   Each element in the list corresponds to the products of the enzyme on the
#'   corresponding glycan in `glycans`.
#' @noRd
.apply_enzyme <- function(glycans, enzyme) {
  rule_res <- purrr::map(enzyme$rules, ~ .apply_rule(glycans, .x, enzyme$type))
  res <- purrr::pmap(rule_res, c)
  purrr::map(res, unique)
}

#' Apply an enzyme rule to a vector of glycan structures
#'
#' @param glycans A `glyrepr_structure` vector.
#' @param rule A `glyenzy_enzyme_rule` object.
#' @param type The type of the enzyme, "GT" or "GH".
#'
#' @returns A list of `glyrepr_structure` vectors, with the same length as `glycans`.
#'   Each element in the list corresponds to the products of the enzyme on the
#'   corresponding glycan in `glycans`.
#' @noRd
.apply_rule <- function(glycans, rule, type) {
  rule_matches <- .match_rule(glycans, rule)
  glyrepr::smap2(glycans, rule_matches, ~ .apply_rule_single(.x, .y, rule, type))
}

#' Apply a single rule to a glycan graph
#'
#' @param graph An igraph object representing the glycan structure.
#' @param match_res A list of integer vectors, representing the node mapping from the acceptor to the glycan.
#' @param rule A `glyenzy_enzyme_rule` object.
#' @param type The type of the enzyme, "GT" or "GH".
#'
#' @returns A list of `glyrepr_structure` vectors, with the same length as `match_res`.
#' @noRd
.apply_rule_single <- function(graph, match_res, rule, type) {
  indices_to_act_on <- purrr::map_int(match_res, ~ .x[rule$acceptor_idx])
  graph_list <- switch(
    type,
    GT = purrr::map(indices_to_act_on, ~ .add_residue(graph, .x, rule$new_residue, rule$new_linkage)),
    GH = purrr::map(indices_to_act_on, ~ .remove_residue(graph, .x)),
    cli::cli_abort("Unsupported enzyme type: {type}")
  )
  graph_list <- purrr::compact(graph_list)
  glyrepr::as_glycan_structure(graph_list)
}

#' Match a rule's acceptor on a glycan structure
#'
#' @param glycans A `glyrepr_structure` vector
#' @param rule A `glyenzy_enzyme_rule` object.
#'
#' @returns A nested list with two layers: the outer layer corresponds to the
#'   glycans in `glycans`, and the inner layer corresponds to different matches
#'   of the rule on the corresponding glycan.
#' @noRd
.match_rule <- function(glycans, rule) {
  res <- glymotif::match_motif(glycans, rule$acceptor, rule$acceptor_alignment)
  if (length(rule$rejects) > 0) {
    rej_match_res <- glymotif::match_motifs(glycans, rule$rejects, rule$acceptor_alignment)
    res <- .reject_matches(res, rej_match_res)
  }
  res
}

#' Update the match results of the acceptor to exclude the reject matches
#'
#' @param acc_match_res A nested list with two layers: the outer layer corresponds to the
#'   glycans in `glycans`, and the inner layer corresponds to different matches
#'   of the rule on the corresponding glycan.
#' @param rej_match_res A nested list with three layers: the outermost layer corresponds to the
#'   reject motifs, the middle layer corresponds to the glycans, and the innermost layer corresponds to
#'   different matches of the reject on the corresponding glycan.
#'
#' @returns An updated version of `acc_match_res` to exclude the reject matches.
#' @noRd
.reject_matches <- function(acc_match_res, rej_match_res) {
  updated_res <- vector("list", length(acc_match_res))
  for (i in seq_along(acc_match_res)) {
    # i means the i-th glycan

    # ===== Reject Matching Algorithm Details =====

    # For each glycan, it can have multiple matches of the acceptor.
    # Each match is a integer vector of the node indices in the glycan that are matched.
    # Also, for each glycan, it can have multiple matches of the reject motifs (yes, maybe more than one reject motifs).
    # A match is considered to be "valid" if it is not a subset of any reject match.
    # Note that we don't care which motif the reject match is from,
    # because any reject motif can cause the enzyme to reject the glycan match.

    # ===== End of Reject Matching Algorithm Details =====

    acc_match_i <- acc_match_res[[i]]  # unknown length
    rej_match_i <- purrr::map(rej_match_res, purrr::pluck, i)  # outer: length(rule$rejects), inner: unknown length
    rej_match_i <- purrr::list_flatten(rej_match_i)
    to_reject_i <- purrr::map_lgl(acc_match_i, .reject_one_match, rej_matches = rej_match_i)
    updated_res[[i]] <- acc_match_i[!to_reject_i]
  }
  updated_res
}

#' Whether to reject one glycan match based on the reject matches
#'
#' @param acc_match A integer vector, one match result of the acceptor on a glycan.
#' @param rej_matches All matches of the reject motifs on the same glycan.
#'
#' @returns A logical scalar, TRUE if the match should be rejected, FALSE otherwise.
#' @noRd
.reject_one_match <- function(acc_match, rej_matches) {
  is_subset_of <- function(a, b) all(a %in% b)
  purrr::some(rej_matches, ~ is_subset_of(acc_match, .x))
}

#' Add a residue to a glycan graph
#'
#' @param graph An igraph object representing the glycan structure.
#' @param idx_to_add_on The index of the node to add the new residue on.
#' @param new_residue The new residue "mono" to add.
#' @param new_linkage The "linkage" of the new residue.
#'
#' @returns A new igraph object with the new residue added,
#'   or NULL if the new residue cannot be added.
#' @noRd
.add_residue <- function(graph, idx_to_add_on, new_residue, new_linkage) {
  idx_to_add <- igraph::vcount(graph) + 1
  new_graph <- graph
  new_graph <- igraph::add_vertices(new_graph, 1, attr = list(name = idx_to_add, mono = new_residue, sub = ""))
  new_graph <- igraph::add_edges(new_graph, c(idx_to_add_on, idx_to_add), attr = list(linkage = new_linkage))
  tryCatch({
    glyrepr:::validate_single_glycan_structure(new_graph)
  }, error = function(e) return(NULL))
}

#' Remove a residue from a glycan graph
#'
#' Only allow removing a terminal (leaf) residue. If the target residue has
#' children (i.e., out-degree > 0), the removal would split the tree into a
#' forest and violate the out-tree invariant. In such cases, return NULL so the
#' caller can drop this invalid product.
#'
#' @param graph An igraph object representing the glycan structure.
#' @param idx_to_remove The index of the node to remove.
#'
#' @returns A new igraph object with the residue removed, or NULL when the
#'   residue is not terminal.
#' @noRd
.remove_residue <- function(graph, idx_to_remove) {
  # Ensure the residue is terminal; otherwise, removing it breaks the out-tree
  if (igraph::degree(graph, v = idx_to_remove, mode = "out") > 0) {
    return(NULL)
  }
  edges <- igraph::incident(graph, idx_to_remove, mode = "all")
  new_graph <- igraph::delete_edges(graph, edges)
  new_graph <- igraph::delete_vertices(new_graph, idx_to_remove)
  # Reset vertex names to maintain consistency with indices after deletion
  igraph::V(new_graph)$name <- as.character(seq_len(igraph::vcount(new_graph)))
  # Validate; if invalid for any reason, signal caller to drop it
  tryCatch({
    glyrepr:::validate_single_glycan_structure(new_graph)
  }, error = function(e) return(NULL))
}
