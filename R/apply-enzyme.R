#' Apply an Enzyme to a Glycan
#'
#' This function simulates the action of an enzyme on a glycan.
#' It returns all possible products generated by the enzyme with the given glycans.
#'
#' @inheritSection is_synthesized_by Important notes
#'
#' @param glycans A [glyrepr::glycan_structure()], or a character vector of
#'   glycan structure strings supported by [glyparse::auto_parse()].
#' @param enzyme An [enzyme()] or a gene symbol.
#' @param return_list If `NULL` (default),
#'   return a list of [glyrepr::glycan_structure()] when `glycans` has length greater than 1,
#'   and a single [glyrepr::glycan_structure()] when `glycans` has length 1.
#'   Set to `TRUE` to always return a list.
#'   This can be useful when you are working programmatically with unknown input length.
#'   Note that when `return_list = FALSE` and `length(glycans) > 1`,
#'   an error will be thrown.
#'
#' @return A [glyrepr::glycan_structure()] vector, or a list of such vectors.
#'
#' @examples
#' library(glyrepr)
#' library(glyparse)
#'
#' # Use `glycan_structure()` and `enzyme()`
#' glycan <- auto_parse("GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-")
#' apply_enzyme(glycan, enzyme("MGAT3"))
#'
#' # Or use characters directly
#' apply_enzyme("GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-", "MGAT3")
#'
#' # Vectorized input
#' glycans <- c(
#'   "GlcNAc(b1-2)Man(a1-3)[Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-",
#'   "GlcNAc(b1-2)Man(a1-3)[GlcNAc(b1-2)Man(a1-6)]Man(b1-4)GlcNAc(b1-4)GlcNAc(b1-"
#' )
#' apply_enzyme(glycans, "MGAT3")
#'
#' @export
apply_enzyme <- function(glycans, enzyme, return_list = NULL) {
  glycans <- .process_glycans_arg(glycans)
  enzyme <- .process_enzyme_arg(enzyme)
  return_list <- .validate_return_list(return_list, length(glycans))

  res <- .apply_enzyme(glycans, enzyme)
  .format_result(res, return_list)
}

#' Apply an enzyme to a vector of glycan structures
#'
#' @param glycans A `glyrepr_structure` vector.
#' @param enzyme A `glyenzy_enzyme` object.
#'
#' @returns A list of `glyrepr_structure` vectors, with the same length as `glycans`.
#'   Each element in the list corresponds to the products of the enzyme on the
#'   corresponding glycan in `glycans`.
#' @noRd
.apply_enzyme <- function(glycans, enzyme) {
  rule_res <- purrr::map(enzyme$rules, ~ .apply_rule(glycans, .x, enzyme$type))
  res <- purrr::pmap(rule_res, c)
  purrr::map(res, unique)
}

#' Apply an enzyme rule to a vector of glycan structures
#'
#' @param glycans A `glyrepr_structure` vector.
#' @param rule A `glyenzy_enzyme_rule` object.
#' @param type The type of the enzyme, "GT" or "GH".
#'
#' @returns A list of `glyrepr_structure` vectors, with the same length as `glycans`.
#'   Each element in the list corresponds to the products of the enzyme on the
#'   corresponding glycan in `glycans`.
#' @noRd
.apply_rule <- function(glycans, rule, type) {
  rule_matches <- .match_rule(glycans, rule)
  glyrepr::smap2(glycans, rule_matches, ~ .apply_rule_single(.x, .y, rule, type))
}

#' Apply a single rule to a glycan graph
#'
#' @param graph An igraph object representing the glycan structure.
#' @param match_res A list of integer vectors, representing the node mapping from the acceptor to the glycan.
#' @param rule A `glyenzy_enzyme_rule` object.
#' @param type The type of the enzyme, "GT" or "GH".
#'
#' @returns A list of `glyrepr_structure` vectors, with the same length as `match_res`.
#' @noRd
.apply_rule_single <- function(graph, match_res, rule, type) {
  indices_to_act_on <- purrr::map_int(match_res, ~ .x[rule$acceptor_idx])
  if (type == "GT") {
    graph_list <- purrr::map(indices_to_act_on, ~ .add_residue(graph, .x, rule$new_residue, rule$new_linkage))
    graph_list <- purrr::compact(graph_list)
  } else {
    graph_list <- purrr::map(indices_to_act_on, ~ .remove_residue(graph, .x))
    graph_list <- purrr::compact(graph_list)
  }
  glyrepr::as_glycan_structure(graph_list)
}

#' Match a rule's acceptor on a glycan structure
#'
#' @param glycans A `glyrepr_structure` vector
#' @param rule A `glyenzy_enzyme_rule` object.
#'
#' @returns A nested list with two layers: the outer layer corresponds to the
#'   glycans in `glycans`, and the inner layer corresponds to different matches
#'   of the rule on the corresponding glycan.
#' @noRd
.match_rule <- function(glycans, rule) {
  if (length(rule$rejects) > 0) {
    have_rejects_mat <- glymotif::have_motifs(glycans, rule$rejects, rule$rejects_alignment)
    have_rejects <- unname(rowSums(have_rejects_mat) > 0)
  } else {
    have_rejects <- rep(FALSE, length(glycans))
  }
  res <- glymotif::match_motif(glycans, rule$acceptor, rule$acceptor_alignment)
  res[have_rejects] <- list(list())
  res
}

#' Add a residue to a glycan graph
#'
#' @param graph An igraph object representing the glycan structure.
#' @param idx_to_add_on The index of the node to add the new residue on.
#' @param new_residue The new residue "mono" to add.
#' @param new_linkage The "linkage" of the new residue.
#'
#' @returns A new igraph object with the new residue added,
#'   or NULL if the new residue cannot be added.
#' @noRd
.add_residue <- function(graph, idx_to_add_on, new_residue, new_linkage) {
  idx_to_add <- igraph::vcount(graph) + 1
  new_graph <- graph
  new_graph <- igraph::add_vertices(new_graph, 1, attr = list(name = idx_to_add, mono = new_residue, sub = ""))
  new_graph <- igraph::add_edges(new_graph, c(idx_to_add_on, idx_to_add), attr = list(linkage = new_linkage))
  tryCatch({
    glyrepr:::validate_single_glycan_structure(new_graph)
  }, error = function(e) return(NULL))
}

#' Remove a residue from a glycan graph
#'
#' Only allow removing a terminal (leaf) residue. If the target residue has
#' children (i.e., out-degree > 0), the removal would split the tree into a
#' forest and violate the out-tree invariant. In such cases, return NULL so the
#' caller can drop this invalid product.
#'
#' @param graph An igraph object representing the glycan structure.
#' @param idx_to_remove The index of the node to remove.
#'
#' @returns A new igraph object with the residue removed, or NULL when the
#'   residue is not terminal.
#' @noRd
.remove_residue <- function(graph, idx_to_remove) {
  # Ensure the residue is terminal; otherwise, removing it breaks the out-tree
  if (igraph::degree(graph, v = idx_to_remove, mode = "out") > 0) {
    return(NULL)
  }
  edges <- igraph::incident(graph, idx_to_remove, mode = "all")
  new_graph <- igraph::delete_edges(graph, edges)
  new_graph <- igraph::delete_vertices(new_graph, idx_to_remove)
  # Reset vertex names to maintain consistency with indices after deletion
  igraph::V(new_graph)$name <- as.character(seq_len(igraph::vcount(new_graph)))
  # Validate; if invalid for any reason, signal caller to drop it
  tryCatch({
    glyrepr:::validate_single_glycan_structure(new_graph)
  }, error = function(e) return(NULL))
}
